# cgroup
리눅스에서 기본적으로 모든 프로세스가 시스템 자원을 공평하게 사용
하지만 다음과 같은 상황에서 제어 필요
- 어떤 프로세스가 메모리를 과도하게  써서 시스템 전체가 느려지는 거 방지하고 싶을 때
- 특정 컨테이너에 CPU 사용량을 제한하고 싶을 때
- 자식 프로세스 포함 전체 자원 사용량을 그룹 단위로 모니터링하고 싶을 때

# cgroup의 기능
리소스 제한: 메모리, CPU, 블록 I/O, 네트워크 사용량 제한 가능
격리: 각 그룹 간 자원 간섭 방지(컨테이너 간 독립성 확보)
계층화: 그룹을 계층적으로 구성해 하위 그룹도 관리 가능
모니터링: 각 그룹이 실제로 사용한 리소스 추적 가능
우선순위: CPU나 I/O에 대한 우선순위 설정 가능

# cgroup과 컨테이너와의 관계
컨테이너 기술(예: Docker, Kubernetes)는 내부적으로 다음 커널 기능 활용
- NameSpace: 프로세스, 네트워크, 파일 시스템 등을 격리
- cgroup: 각 컨테이너의 리소스를 제한 및 추적
즉, 컨테이너는 cgroup + namespace를 이용해 마치 독립된 OS처럼 보이는 프로세스를 실행

# 독립된 OS처럼 보이는 프로세스?
1. Namespace: 격리의 핵심
Namespace는 컨테이너가 자신만의 세상에 있는 것처럼 보이게 하는 가장 중요한 요소

## Namespace 종류
PID: 다른 컨테이너의 프로세스 안 보임 -> 내가 PID 1이네?
NET: 독립된 IP, 포트 공간 -> 마치 독립된 서버처럼 보임
MNT: 자신만의 파일 시스템 마운트 구조
UTS: hostname이 독립됨
USER: root처럼 보이지만 실제로는 호스트에선 일반 유저

컨테이너 내부에서는 프로세스 리스트를 보면 init 프로세스가 PID 1부터 시작됨 -> 실제로는 host의 하위 프로세스일 뿐이지만, 컨테이너 내부에선 완전한 OS처럼 보임

## 파일 시스템 격리(chroot, OverlayFS)
루트 디렉토리가 격리됨(/가 호스트와 다름)
마치 자신의 고유한 파일 시스템을 가진 것처럼 보임
실제로는 호스트의 특정 디렉토리만 사용하는 것리

# cgroup 드라이버
둘 중에 하나 선택되어야 하며 kubelet과 컨테이너 런타임(Docker, containerd 등)이 각각 다른 cgroup 드라이버 사용하면 문제 가능성 있음
- cgroupfs
- systemd

# Docker가 이미지를 빌드하는건 컨테이너 런타임의 주된 기능과는 별개
컨테이너 런타임의 주요 기능은 컨테이너 생성, 삭제, 관리, 격리 및 제한으로 이미지 빌드는 요구사항이 아님
다만 도커는 이미지 빌드 기능이 추가되어 많은 사람들이 자연스럽게 많이 사용하게 되었음
컨테이너 런타임을 Docker가 아닌 containerd나 CRI-O를 쓰더라도 이미지 빌드는 주로 Docker를 사용
Buildah, Kaniko, img, Docker Buildx 등을 통해서도 빌드 가능
